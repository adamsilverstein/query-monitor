import fs from 'fs';

const dir = './src/schemas';
const files = fs.readdirSync( dir );

for ( const file of files ) {
	const schema = JSON.parse( fs.readFileSync( `${dir}/${file}`, 'utf8' ) );
	const basename = file.split( '.' )[0];

	let output = `<?php declare(strict_types = 1);
/**
 * This file is generated by the generate.mjs script.
 * Do not edit it manually.
 */

/**
 * ${schema.description}
 *
 * @package query-monitor
 */

class QM_Data_${schema.title} extends QM_Data {`;

	for ( const key in schema.properties ) {
		const requiredMarker = schema.required && schema.required.includes( key ) ? '' : '?';
		const prop = schema.properties[key];
		let phpStanVar = null;

		output += `
	/**`;

		if ( prop.phpStanVar ) {
			phpStanVar = prop.phpStanVar;
		} else if ( ! prop.tsType ) {
			switch ( prop.type ) {
				case 'object':
					phpStanVar = 'array{';
					for ( const subKey in prop.properties ) {
						const subRequiredMarker = prop.required && prop.required.includes( subKey ) ? '' : '?';
						const sub = prop.properties[subKey];

						phpStanVar += `
	 *   ${subKey}${subRequiredMarker}: ${mapType( ( sub.tsType || sub.type ), sub )},`;
					}
					phpStanVar += `
	 * }`;
					break;
				default:
					break;
			}
		}

		if ( phpStanVar ) {
			output += `
	 * @phpstan-var ${requiredMarker}${phpStanVar}`;
		} else {
			output += `
	 * @var ${requiredMarker}${mapType( ( prop.tsType || prop.type ), prop )}`;
		}

		output += `
	 */
	public $${key};
`;
	}

	output += `}
`;

	fs.writeFileSync( `./data/${basename}.php`, output );
}

function mapType( type, prop ) {
	if ( typeof type == 'object' ) {
		return type.map( ( t ) => mapType( t, prop ) ).join( '|' );
	}

	switch ( type ) {
		case 'number':
			return 'int';
		case 'boolean':
			return 'bool';
		case 'array':
			if ( prop.items ) {
				return `array<int, ${mapType( ( prop.items.tsType || prop.items.type ), prop.items )}>`;
			}
			return 'array<int, mixed>';
		default:
			return type;
	}
}
