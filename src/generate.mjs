import fs from 'fs';

const dir = './src/schemas';
const files = fs.readdirSync( dir );

for ( const file of files ) {
	const schema = JSON.parse( fs.readFileSync( `${dir}/${file}`, 'utf8' ) );
	const basename = file.split( '.' )[0];

	let output = `<?php declare(strict_types = 1);
/**
 * This file is generated by the generate.mjs script.
 * Do not edit it manually.
 */

/**
 * ${schema.description}
 *
 * @package query-monitor
 */
${schema.$comment ? `\n${schema.$comment}` : ''}
class QM_Data_${schema.title} extends QM_Data {`;

	for ( const key in schema.properties ) {
		const required = schema.required && schema.required.includes( key );
		const prop = schema.properties[key];

		output += `
	/**`;

		const type = mapType( prop, required );

		if ( type.includes( 'array{' ) || prop.phpStanType ) {
			output += `
	 * @phpstan-var ${type}`;
		} else {
			output += `
	 * @var ${type}`;
		}

		output += `
	 */
	public $${key};
`;
	}

	output += `}
`;

	fs.writeFileSync( `./data/${basename}.php`, output );
}

/**
 * @param {object} prop
 * @param {boolean} required
 * @param {number} level
 * @returns {string}
 */
function mapType( prop, required, level = 0 ) {
	const type = prop.enum || prop.type;
	const requiredMarker = required ? '' : '?';
	let returnType = type;

	if ( typeof type === 'undefined' ) {
		return `${requiredMarker}mixed`;
	}

	if ( prop.phpStanType || prop.phpType ) {
		return `${requiredMarker}${prop.phpStanType || prop.phpType}`;
	}

	if ( typeof type == 'object' ) {
		return `${requiredMarker}${ type.map( getPHPType ).join( '|' ) }`;
	}

	const indentation = '  '.repeat( level );

	switch ( type ) {
		case 'array':
			if ( prop.items ) {
				returnType = `array<int, ${mapType( prop.items, true, level )}>`;
			} else {
				returnType = 'array<int, mixed>';
			}
			break;
		case 'object':
			if ( prop.properties ) {
				let type = 'array{';
				for ( const subKey in prop.properties ) {
					const subRequiredMarker = prop.required && prop.required.includes( subKey ) ? '' : '?';
					const sub = prop.properties[subKey];

					type += `
\t *${indentation}   ${subKey}${subRequiredMarker}: ${mapType( sub, true, level + 1 )},`;
				}
				type += `
\t *${indentation} }`;
				returnType = type;
			} else if ( prop.additionalProperties?.type ) {
				returnType = `array<string, ${mapType( prop.additionalProperties, true, level )}>`;
			} else {
				returnType = 'array<string, mixed>';
			}
			break;
		default:
			returnType = getPHPType( type );
			break;
	}

	return `${requiredMarker}${returnType}`;
}

/**
 * @param {string} type
 * @returns {string}
 */
function getPHPType( type ) {
	switch ( type ) {
		case 'string':
			return 'string';
		case 'null':
			return 'null';
		case 'number':
			return 'float';
		case 'integer':
			return 'int';
		case 'boolean':
			return 'bool';
		case 'array':
		case 'object':
			return 'array';
		default:
			return `'${type}'`;
	}
}
